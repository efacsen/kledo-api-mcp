---
phase: 06-smart-mcp-server-onboarding
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified: [src/cli.py, kledo_mcp.py, src/server.py]
autonomous: true

must_haves:
  truths:
    - "kledo-mcp --setup runs the setup wizard explicitly"
    - "kledo-mcp --test validates API connection without starting server"
    - "kledo-mcp --show-config outputs valid Claude Desktop JSON"
    - "kledo-mcp with no args detects first-run and prompts setup"
    - "All commands are idempotent (safe to run multiple times)"
  artifacts:
    - path: "src/cli.py"
      provides: "Command-line argument parsing and command handlers"
      min_lines: 200
      exports: ["parse_args", "handle_setup", "handle_test", "handle_show_config"]
    - path: "kledo_mcp.py"
      provides: "Updated entry point with first-run detection"
      min_lines: 80
      contains: "parse_args"
  key_links:
    - from: "kledo_mcp.py"
      to: "src/cli.py"
      via: "Argument parsing and command routing"
      pattern: "from src\\.cli import parse_args"
    - from: "src/cli.py"
      to: "src/setup.py"
      via: "Setup wizard invocation"
      pattern: "from src\\.setup import run_setup_wizard"
    - from: "kledo_mcp.py"
      to: "src.server"
      via: "Server startup after config validated"
      pattern: "subprocess.*src\\.server"
---

<objective>
Integrate setup wizard into entry point and add CLI commands for validation and configuration display.

Purpose: Make first-run seamless and provide utility commands for troubleshooting
Output: kledo-mcp command works with --setup, --test, --show-config, --init, and auto-detects first-run
</objective>

<execution_context>
@~/.claude/gsd-css/workflows/execute-plan.md
@~/.claude/gsd-css/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current codebase
@kledo_mcp.py
@src/server.py
@src/auth.py

# Prior work
@.planning/phases/06-smart-mcp-server-onboarding/06-01-SUMMARY.md
@src/setup.py
@src/config_manager.py
</context>

<tasks>

<task type="auto">
  <name>Create CLI argument parser and command handlers</name>
  <files>src/cli.py</files>
  <action>
Create `src/cli.py` with argparse and command handlers:

**parse_args() -> argparse.Namespace:**
```python
parser = argparse.ArgumentParser(
    prog="kledo-mcp",
    description="Kledo MCP Server - AI-powered access to Kledo accounting data"
)

# Commands (mutually exclusive)
parser.add_argument("--setup", action="store_true",
    help="Run interactive setup wizard")
parser.add_argument("--test", action="store_true",
    help="Test connection to Kledo API")
parser.add_argument("--show-config", action="store_true",
    help="Display Claude Desktop configuration JSON")
parser.add_argument("--init", action="store_true",
    help="Force first-run setup (re-initialize configuration)")
parser.add_argument("--version", action="store_true",
    help="Show version information")
```

**handle_setup() -> int:**
- Call `run_setup_wizard()` from src.setup
- Return exit code (0=success, 1=failure)
- Idempotent: safe to run multiple times

**handle_test() -> int:**
- Load config from .env using python-dotenv
- Create KledoAuthenticator instance
- Call `auth.login()` to test connection
- Print colored output:
  - Success: "âœ“ Connection successful! API key is valid."
  - Failure: "âœ— Connection failed: [error details]"
- Return 0 on success, 1 on failure

**handle_show_config() -> int:**
- Load current working directory absolute path
- Generate Claude Desktop config JSON:
  ```json
  {
    "mcpServers": {
      "kledo-crm": {
        "command": "kledo-mcp",
        "env": {
          "KLEDO_API_KEY": "YOUR_API_KEY_HERE",
          "KLEDO_BASE_URL": "https://api.kledo.com/api/v1",
          "CACHE_ENABLED": "true",
          "LOG_LEVEL": "INFO"
        }
      }
    }
  }
  ```
- Print instructions:
  ```
  Copy this configuration to your Claude Desktop config file:

  macOS: ~/Library/Application Support/Claude/claude_desktop_config.json
  Windows: %APPDATA%\Claude\claude_desktop_config.json
  Linux: ~/.config/Claude/claude_desktop_config.json

  [JSON here]

  Don't forget to replace YOUR_API_KEY_HERE with your actual API key!
  ```
- Return 0

**handle_version() -> int:**
- Read version from pyproject.toml or hardcode "1.0.0"
- Print: "Kledo MCP Server v1.0.0"
- Return 0

**dispatch_command(args: argparse.Namespace) -> int:**
Route to appropriate handler based on args.

**Why these specifics:**
- Argparse is stdlib, no dependencies
- Each command isolated = easy testing
- Exit codes enable scripting
- --show-config reduces copy-paste errors
- Instructions minimize support questions
  </action>
  <verify>
1. Import: `python -c "from src.cli import parse_args; print('OK')"`
2. Parse test: `python -c "from src.cli import parse_args; args = parse_args(['--version']); print(args.version)"`
3. Help text: `python -m src.cli --help` should show all commands
  </verify>
  <done>
- parse_args() handles all 5 commands
- Each handler returns proper exit code
- --show-config outputs valid JSON
- --test validates connection using KledoAuthenticator
- Color codes used for status messages
- Help text clear and concise
  </done>
</task>

<task type="auto">
  <name>Update entry point with first-run detection</name>
  <files>kledo_mcp.py</files>
  <action>
Update `kledo_mcp.py` to integrate CLI and first-run detection:

**New main() logic:**
```python
def main():
    """Entry point with first-run detection and CLI support."""
    import sys
    from pathlib import Path

    # Add src to path (keep existing pattern)
    src_dir = Path(__file__).parent / "src"
    if str(src_dir) not in sys.path:
        sys.path.insert(0, str(src_dir))

    from src.cli import parse_args, dispatch_command
    from src.setup import SetupWizard

    # Parse command-line arguments
    args = parse_args(sys.argv[1:])

    # If command specified, dispatch it
    if any([args.setup, args.test, args.show_config, args.init, args.version]):
        return dispatch_command(args)

    # No command: check first-run
    wizard = SetupWizard()
    if wizard.detect_first_run():
        print("\nðŸš€ Welcome to Kledo MCP Server!")
        print("Let's set up your connection to Kledo API.\n")

        if wizard.run():
            print("\nâœ“ Setup complete! Starting server...\n")
        else:
            print("\nâœ— Setup failed. Please try again.")
            return 1

    # Start server (keep existing subprocess pattern)
    import subprocess
    import os

    script_dir = Path(__file__).parent
    env = os.environ.copy()
    env['PYTHONPATH'] = f"{str(src_dir)}:{env.get('PYTHONPATH', '')}"

    result = subprocess.run(
        [sys.executable, "-m", "src.server"],
        cwd=script_dir,
        env=env
    )

    return result.returncode
```

**Why these specifics:**
- First-run check before server start = seamless onboarding
- CLI commands bypass first-run detection = explicit control
- Keep existing subprocess pattern = backward compatible
- Print friendly welcome = better UX than silent setup
  </action>
  <verify>
1. Syntax check: `python kledo_mcp.py --version`
2. Help check: `python kledo_mcp.py --help`
3. Parse check: `python -c "import kledo_mcp; print('OK')"`
  </verify>
  <done>
- main() integrates parse_args and dispatch_command
- First-run detection triggers setup wizard automatically
- CLI commands work: --setup, --test, --show-config, --init, --version
- Server starts after successful first-run setup
- Backward compatible with existing subprocess pattern
  </done>
</task>

<task type="auto">
  <name>Add CLI integration tests</name>
  <files>tests/test_cli.py</files>
  <action>
Create `tests/test_cli.py` with integration tests:

**Test argument parsing:**
- `test_parse_args_setup()` - --setup flag parsed
- `test_parse_args_test()` - --test flag parsed
- `test_parse_args_show_config()` - --show-config flag parsed
- `test_parse_args_init()` - --init flag parsed
- `test_parse_args_version()` - --version flag parsed
- `test_parse_args_no_args()` - Empty args handled

**Test command handlers:**
- `test_handle_setup(monkeypatch)` - Mock run_setup_wizard
- `test_handle_test_success(monkeypatch)` - Mock successful auth
- `test_handle_test_failure(monkeypatch)` - Mock failed auth
- `test_handle_show_config(capsys)` - Verify JSON output
- `test_handle_version(capsys)` - Verify version output

**Test dispatch:**
- `test_dispatch_command_routes_correctly()` - All commands routed

**Use pytest features:**
- `monkeypatch` fixture for mocking imports
- `capsys` fixture for capturing output
- Mock external dependencies (auth, setup wizard)

**Why these specifics:**
- Integration tests validate CLI wiring
- Mocking prevents actual setup runs during tests
- capsys verifies printed output format
  </action>
  <verify>
Run: `pytest tests/test_cli.py -v`
Should show: All tests passed, no actual API calls made
  </verify>
  <done>
- Tests for all argument combinations
- Tests for all command handlers
- Tests mock external dependencies
- Output verification for --show-config and --version
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. Command parsing: `python kledo_mcp.py --help`
2. Version check: `python kledo_mcp.py --version`
3. Config display: `python kledo_mcp.py --show-config` (outputs valid JSON)
4. Unit tests: `pytest tests/test_cli.py -v`
5. Entry point: `python -c "import kledo_mcp; print('OK')"`
</verification>

<success_criteria>
- [ ] All 5 CLI commands implemented (--setup, --test, --show-config, --init, --version)
- [ ] Entry point detects first-run and triggers setup wizard
- [ ] --show-config outputs valid Claude Desktop JSON
- [ ] --test validates connection without starting server
- [ ] Commands are idempotent (safe to run multiple times)
- [ ] Unit tests pass with >80% coverage
- [ ] Backward compatible with python -m src.server
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-mcp-server-onboarding/06-02-SUMMARY.md`
</output>
