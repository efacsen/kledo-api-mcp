---
phase: 01-entity-registry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/__init__.py
  - src/entities/models/__init__.py
  - src/entities/models/base.py
  - src/entities/models/contact.py
  - src/entities/models/product.py
  - src/entities/models/invoice.py
autonomous: true

must_haves:
  truths:
    - "Contact entity has all fields used by contact tools (name, company, email, phone, type_id, address, receivable, payable)"
    - "Product entity has all fields used by product tools (name, code, price, buy_price, qty, category)"
    - "Invoice entity has all fields used by invoice tools (trans_number, trans_date, contact_id, status, amounts, detail items)"
    - "Entity relationships are encoded in Field metadata (contact_id references Contact)"
  artifacts:
    - path: "src/entities/__init__.py"
      provides: "Package init exporting entity models"
    - path: "src/entities/models/base.py"
      provides: "BaseEntity model with common fields (id, created_at, updated_at)"
      min_lines: 15
    - path: "src/entities/models/contact.py"
      provides: "Contact entity definition"
      exports: ["Contact"]
    - path: "src/entities/models/product.py"
      provides: "Product entity with Warehouse embedded type"
      exports: ["Product", "Warehouse"]
    - path: "src/entities/models/invoice.py"
      provides: "Invoice and InvoiceItem entities"
      exports: ["Invoice", "InvoiceItem"]
  key_links:
    - from: "src/entities/models/invoice.py"
      to: "Contact"
      via: "contact_id field with relationship metadata"
      pattern: "relationship.*Contact"
    - from: "src/entities/models/invoice.py"
      to: "Product"
      via: "InvoiceItem.product_id field"
      pattern: "relationship.*Product"
---

<objective>
Create Pydantic entity models for core Kledo business objects: Contact, Product, and Invoice.

Purpose: Establish the foundational entity definitions that all downstream documentation and routing will reference. These models capture the actual field structure used by existing tools.

Output: `src/entities/models/` directory with validated Pydantic models ready for YAML export and ERD generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-entity-registry/01-CONTEXT.md
@.planning/phases/01-entity-registry/01-RESEARCH.md

# Existing tools showing field usage
@src/tools/contacts.py
@src/tools/products.py
@src/tools/invoices.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base entity model and package structure</name>
  <files>
    src/entities/__init__.py
    src/entities/models/__init__.py
    src/entities/models/base.py
  </files>
  <action>
    Create the entities package structure:

    1. `src/entities/__init__.py` - Package init, will export loader functions (added in Plan 03)

    2. `src/entities/models/__init__.py` - Re-export all entity models for convenient imports

    3. `src/entities/models/base.py` - BaseEntity Pydantic model with:
       - `id: int` (unique identifier)
       - `created_at: Optional[datetime]` (creation timestamp)
       - `updated_at: Optional[datetime]` (last update timestamp)
       - Use `Field()` with descriptions for each field
       - Configure `model_config` with `from_attributes=True` for ORM compatibility

    Use Pydantic V2 patterns per RESEARCH.md. Import from `pydantic` not `pydantic.v1`.
  </action>
  <verify>
    Run: `python -c "from src.entities.models.base import BaseEntity; print(BaseEntity.model_json_schema())"`
    Should output JSON schema without errors.
  </verify>
  <done>BaseEntity model exists and can generate JSON schema</done>
</task>

<task type="auto">
  <name>Task 2: Create Contact entity model</name>
  <files>src/entities/models/contact.py</files>
  <action>
    Create Contact entity based on fields from `contacts.py` tool:

    ```python
    class Contact(BaseEntity):
        name: str = Field(description="Contact's full name")
        company: Optional[str] = Field(default=None, description="Company/organization name")
        email: Optional[str] = Field(default=None, description="Email address")
        phone: Optional[str] = Field(default=None, description="Phone number")
        address: Optional[str] = Field(default=None, description="Physical address")
        type_id: int = Field(
            description="Contact type: 1=Customer, 2=Vendor, 3=Both",
            json_schema_extra={"enum_values": {1: "Customer", 2: "Vendor", 3: "Both"}}
        )
        type_name: Optional[str] = Field(default=None, description="Denormalized type name")
        total_receivable: Decimal = Field(default=0, description="Amount owed by this contact")
        total_payable: Decimal = Field(default=0, description="Amount owed to this contact")
    ```

    Use `Decimal` for currency fields per RESEARCH.md (avoid float precision issues).
    Add `Field(examples=[...])` with realistic examples where helpful.
  </action>
  <verify>
    Run: `python -c "from src.entities.models.contact import Contact; c = Contact(id=1, name='Test', type_id=1); print(c.model_dump_json())"`
  </verify>
  <done>Contact model validates and serializes correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create Product and Invoice entity models</name>
  <files>
    src/entities/models/product.py
    src/entities/models/invoice.py
  </files>
  <action>
    Create Product entity with embedded Warehouse type:

    ```python
    class Warehouse(BaseModel):
        """Warehouse stock location."""
        name: str = Field(description="Warehouse name")
        qty: Decimal = Field(default=0, description="Stock quantity in this warehouse")

    class Product(BaseEntity):
        name: str = Field(description="Product name")
        code: Optional[str] = Field(default=None, description="SKU/product code")
        description: Optional[str] = Field(default=None, description="Product description")
        price: Decimal = Field(default=0, description="Selling price")
        buy_price: Decimal = Field(default=0, description="Cost/purchase price")
        qty: Decimal = Field(default=0, description="Total stock quantity")
        category_id: Optional[int] = Field(default=None, description="Product category reference")
        category_name: Optional[str] = Field(default=None, description="Denormalized category name")
        warehouses: list[Warehouse] = Field(
            default_factory=list,
            description="Stock by warehouse",
            json_schema_extra={"relationship": {"target": "Warehouse", "type": "one-to-many", "embedded": True}}
        )
    ```

    Create Invoice entity with embedded InvoiceItem:

    ```python
    class InvoiceItem(BaseModel):
        """Line item within an invoice."""
        product_id: Optional[int] = Field(
            default=None,
            description="Product reference",
            json_schema_extra={"relationship": {"target": "Product", "type": "many-to-one"}}
        )
        desc: str = Field(description="Item description")
        qty: Decimal = Field(description="Quantity")
        price: Decimal = Field(description="Unit price")
        amount: Decimal = Field(description="Line total (qty * price)")

    class Invoice(BaseEntity):
        trans_number: str = Field(description="Invoice number (e.g., INV-2026-0001)")
        trans_date: date = Field(description="Invoice date")
        due_date: Optional[date] = Field(default=None, description="Payment due date")
        contact_id: int = Field(
            description="Customer/vendor reference",
            json_schema_extra={"relationship": {"target": "Contact", "type": "many-to-one"}}
        )
        contact_name: Optional[str] = Field(default=None, description="Denormalized contact name")
        status_id: int = Field(description="Invoice status ID")
        status_name: Optional[str] = Field(default=None, description="Denormalized status name")
        subtotal: Decimal = Field(default=0, description="Sum of line items before tax")
        tax_amount: Decimal = Field(default=0, description="Total tax amount")
        grand_total: Decimal = Field(default=0, description="Total including tax")
        amount_paid: Decimal = Field(default=0, description="Amount already paid")
        detail: list[InvoiceItem] = Field(
            default_factory=list,
            description="Invoice line items",
            json_schema_extra={"relationship": {"target": "InvoiceItem", "type": "one-to-many", "embedded": True}}
        )
        memo: Optional[str] = Field(default=None, description="Internal notes")
    ```

    Update `src/entities/models/__init__.py` to export all models.
  </action>
  <verify>
    Run: `python -c "from src.entities.models import Contact, Product, Invoice, InvoiceItem; print('All models imported successfully')"`
  </verify>
  <done>Product, Invoice, InvoiceItem models exist and export from package</done>
</task>

</tasks>

<verification>
1. All entity models can be imported: `from src.entities.models import Contact, Product, Invoice`
2. JSON schema generation works: `Contact.model_json_schema()` returns valid schema
3. Relationship metadata is present in schema: Check `contact_id` field has relationship info
4. No circular import errors when importing the package
</verification>

<success_criteria>
- 5 entity models defined (BaseEntity, Contact, Product, Invoice, InvoiceItem) + 1 embedded type (Warehouse)
- All fields from existing tools are captured in entity definitions
- Relationship metadata encoded using `json_schema_extra`
- Package structure allows clean imports: `from src.entities.models import *`
</success_criteria>

<output>
After completion, create `.planning/phases/01-entity-registry/01-01-SUMMARY.md`
</output>
