---
phase: 01-entity-registry
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/entities/loader.py
  - src/entities/__init__.py
  - src/entities/schemas/entities.yaml
  - docs/erd.png
  - requirements.txt
autonomous: true
user_setup:
  - service: graphviz
    why: "ERD diagram generation requires Graphviz binary"
    env_vars: []
    dashboard_config:
      - task: "Install Graphviz system binary"
        location: "Terminal: brew install graphviz (macOS) or apt install graphviz (Linux)"

must_haves:
  truths:
    - "Entity definitions can be loaded programmatically via load_entity() and get_all_entities()"
    - "YAML schema file exists with human-readable entity documentation"
    - "ERD diagram shows all entities and their relationships"
    - "Python loader validates YAML against Pydantic models"
  artifacts:
    - path: "src/entities/loader.py"
      provides: "Entity loading functions"
      exports: ["load_entity", "get_all_entities", "export_yaml_schema"]
    - path: "src/entities/schemas/entities.yaml"
      provides: "Combined YAML schema for all entities"
      contains: "Contact:"
    - path: "docs/erd.png"
      provides: "Visual entity relationship diagram"
  key_links:
    - from: "src/entities/loader.py"
      to: "src/entities/models"
      via: "imports all entity classes"
      pattern: "from .models import"
    - from: "src/entities/__init__.py"
      to: "src/entities/loader.py"
      via: "exports loader functions"
      pattern: "from .loader import"
---

<objective>
Create entity loader utilities and generate YAML schema documentation plus ERD diagram.

Purpose: Make entity definitions programmatically accessible for downstream phases (documentation, routing) and provide visual documentation of the data model.

Output: Working `load_entity()` and `get_all_entities()` functions, exported YAML schema, and PNG ERD diagram.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-entity-registry/01-CONTEXT.md
@.planning/phases/01-entity-registry/01-RESEARCH.md

# Prior plan outputs (entity models must exist)
# Plan 01 and 02 summaries will be created after those plans execute
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity loader module</name>
  <files>
    src/entities/loader.py
    src/entities/__init__.py
  </files>
  <action>
    Create loader.py with functions for programmatic entity access:

    ```python
    """Entity loader utilities for programmatic access to Kledo entity definitions."""
    from pathlib import Path
    from typing import Type, TypeVar
    import yaml

    from pydantic import BaseModel

    from .models import (
        BaseEntity, Contact, Product, Warehouse,
        Invoice, InvoiceItem, Order, OrderItem,
        Delivery, DeliveryItem, Account
    )

    T = TypeVar('T', bound=BaseModel)

    # Registry mapping entity names to their model classes
    ENTITY_REGISTRY: dict[str, Type[BaseModel]] = {
        "contact": Contact,
        "product": Product,
        "invoice": Invoice,
        "order": Order,
        "delivery": Delivery,
        "account": Account,
    }

    # Embedded types (not top-level entities but used within entities)
    EMBEDDED_TYPES: dict[str, Type[BaseModel]] = {
        "warehouse": Warehouse,
        "invoice_item": InvoiceItem,
        "order_item": OrderItem,
        "delivery_item": DeliveryItem,
    }


    def get_entity_class(entity_name: str) -> Type[BaseModel]:
        """Get the Pydantic model class for an entity by name.

        Args:
            entity_name: Entity name (case-insensitive), e.g., 'contact', 'invoice'

        Returns:
            The Pydantic model class

        Raises:
            KeyError: If entity name not found
        """
        name_lower = entity_name.lower()
        if name_lower in ENTITY_REGISTRY:
            return ENTITY_REGISTRY[name_lower]
        if name_lower in EMBEDDED_TYPES:
            return EMBEDDED_TYPES[name_lower]
        raise KeyError(f"Unknown entity: {entity_name}. Available: {list(ENTITY_REGISTRY.keys())}")


    def get_all_entities() -> dict[str, Type[BaseModel]]:
        """Get all top-level entity classes.

        Returns:
            Dict mapping entity names to their Pydantic model classes
        """
        return ENTITY_REGISTRY.copy()


    def get_entity_schema(entity_name: str) -> dict:
        """Get JSON schema for an entity.

        Args:
            entity_name: Entity name

        Returns:
            JSON Schema dict for the entity
        """
        model_class = get_entity_class(entity_name)
        return model_class.model_json_schema()


    def get_all_schemas() -> dict[str, dict]:
        """Get JSON schemas for all entities.

        Returns:
            Dict mapping entity names to their JSON schemas
        """
        schemas = {}
        for name, model_class in ENTITY_REGISTRY.items():
            schemas[name] = model_class.model_json_schema()
        return schemas


    def export_yaml_schema(output_path: Path | str | None = None) -> str:
        """Export all entity schemas to YAML format.

        Args:
            output_path: Optional path to write YAML file

        Returns:
            YAML string of all schemas
        """
        schemas = get_all_schemas()

        # Add metadata header
        output = {
            "_meta": {
                "description": "Kledo Entity Schema Definitions",
                "version": "1.0.0",
                "entities": list(schemas.keys()),
            },
            **schemas
        }

        yaml_str = yaml.dump(output, default_flow_style=False, sort_keys=False, allow_unicode=True)

        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(yaml_str, encoding='utf-8')

        return yaml_str
    ```

    Update `src/entities/__init__.py` to export loader functions:

    ```python
    """Kledo Entity Registry - Machine-readable entity definitions."""

    from .models import (
        BaseEntity, Contact, Product, Warehouse,
        Invoice, InvoiceItem, Order, OrderItem,
        Delivery, DeliveryItem, Account
    )
    from .loader import (
        get_entity_class, get_all_entities,
        get_entity_schema, get_all_schemas,
        export_yaml_schema, ENTITY_REGISTRY, EMBEDDED_TYPES
    )

    __all__ = [
        # Models
        "BaseEntity", "Contact", "Product", "Warehouse",
        "Invoice", "InvoiceItem", "Order", "OrderItem",
        "Delivery", "DeliveryItem", "Account",
        # Loader functions
        "get_entity_class", "get_all_entities",
        "get_entity_schema", "get_all_schemas",
        "export_yaml_schema", "ENTITY_REGISTRY", "EMBEDDED_TYPES",
    ]
    ```
  </action>
  <verify>
    Run: `python -c "from src.entities import get_all_entities; print(list(get_all_entities().keys()))"`
    Expected: `['contact', 'product', 'invoice', 'order', 'delivery', 'account']`
  </verify>
  <done>Loader module exports functions; get_all_entities() returns all 6 entity types</done>
</task>

<task type="auto">
  <name>Task 2: Generate YAML schema file and ERD diagram</name>
  <files>
    src/entities/schemas/entities.yaml
    docs/erd.png
    requirements.txt
  </files>
  <action>
    1. Add erdantic to requirements.txt:
       ```
       # ERD diagram generation
       erdantic>=1.0.0
       ```

    2. Create a script to generate both YAML and ERD (can be run as one-time setup):

       First, create the schemas directory:
       ```bash
       mkdir -p src/entities/schemas
       mkdir -p docs
       ```

    3. Generate YAML schema using the loader:
       ```python
       from src.entities import export_yaml_schema
       export_yaml_schema("src/entities/schemas/entities.yaml")
       ```

    4. Generate ERD diagram using erdantic:
       ```python
       import erdantic as erd
       from src.entities.models import Contact, Product, Invoice, Order, Delivery, Account

       # Create diagram with all main entities
       diagram = erd.create(Contact, Product, Invoice, Order, Delivery, Account)
       diagram.draw("docs/erd.png")
       ```

       Note: This requires graphviz binary installed (`brew install graphviz` on macOS).
       If graphviz is not available, create a placeholder message in docs/erd.png location
       and document the requirement.

    5. Add a simple generation script at `scripts/generate_entity_docs.py`:
       ```python
       #!/usr/bin/env python
       """Generate entity documentation (YAML schema and ERD)."""
       import sys
       from pathlib import Path

       # Add src to path for imports
       sys.path.insert(0, str(Path(__file__).parent.parent))

       from src.entities import export_yaml_schema

       def main():
           # Generate YAML schema
           yaml_path = Path("src/entities/schemas/entities.yaml")
           export_yaml_schema(yaml_path)
           print(f"Generated: {yaml_path}")

           # Generate ERD (if erdantic available)
           try:
               import erdantic as erd
               from src.entities.models import Contact, Product, Invoice, Order, Delivery, Account

               erd_path = Path("docs/erd.png")
               erd_path.parent.mkdir(parents=True, exist_ok=True)
               diagram = erd.create(Contact, Product, Invoice, Order, Delivery, Account)
               diagram.draw(str(erd_path))
               print(f"Generated: {erd_path}")
           except ImportError:
               print("Warning: erdantic not installed. Run: pip install erdantic")
           except Exception as e:
               print(f"Warning: Could not generate ERD: {e}")
               print("Ensure graphviz is installed: brew install graphviz (macOS)")

       if __name__ == "__main__":
           main()
       ```

    6. Run the generation:
       ```bash
       pip install erdantic
       python scripts/generate_entity_docs.py
       ```
  </action>
  <verify>
    Check YAML exists: `ls -la src/entities/schemas/entities.yaml`
    Check YAML content: `head -30 src/entities/schemas/entities.yaml`
    Check ERD exists: `ls -la docs/erd.png` (or note if graphviz not installed)
  </verify>
  <done>YAML schema file exists with all entity definitions; ERD diagram generated (or documented as requiring graphviz)</done>
</task>

</tasks>

<verification>
1. Loader functions work:
   - `get_all_entities()` returns dict of 6 entities
   - `get_entity_class("invoice")` returns Invoice class
   - `get_entity_schema("contact")` returns valid JSON schema

2. YAML schema is complete:
   - File exists at `src/entities/schemas/entities.yaml`
   - Contains all 6 entity definitions
   - YAML is valid and parseable

3. ERD diagram:
   - File exists at `docs/erd.png` (or documentation of graphviz requirement)
   - Shows entity boxes and relationship lines

4. Package exports are complete:
   - `from src.entities import get_all_entities, Contact, Invoice` works
</verification>

<success_criteria>
- `load_entity()` and `get_all_entities()` functions available from `src.entities`
- YAML schema file generated at `src/entities/schemas/entities.yaml`
- ERD diagram at `docs/erd.png` (or clear documentation if graphviz unavailable)
- Generation script exists for future regeneration
- ENTY-01, ENTY-02, ENTY-03 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-entity-registry/01-03-SUMMARY.md`
</output>
