---
phase: 04-smart-routing
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - src/routing/patterns.py
  - src/routing/scorer.py
  - src/routing/router.py
  - src/routing/__init__.py
autonomous: true

must_haves:
  truths:
    - "Idiomatic expressions resolve to specific tools with parameter hints"
    - "Ambiguous queries return multiple ranked tool suggestions"
    - "Action verbs influence tool type ranking (list/search/summary)"
    - "Vague queries return clarification prompt instead of arbitrary tools"
    - "Indonesian and English queries produce equivalent results"
  artifacts:
    - path: "src/routing/patterns.py"
      provides: "Pattern library for compound expressions"
      exports: ["PATTERNS", "match_pattern"]
    - path: "src/routing/scorer.py"
      provides: "Keyword-based relevance scoring"
      exports: ["score_tool", "extract_keywords"]
    - path: "src/routing/router.py"
      provides: "Main routing logic"
      exports: ["route_query", "ToolSuggestion", "RoutingResult"]
  key_links:
    - from: "src/routing/router.py"
      to: "src/routing/synonyms.py"
      via: "normalize_term for query preprocessing"
      pattern: "normalize_term"
    - from: "src/routing/router.py"
      to: "src/routing/patterns.py"
      via: "match_pattern for idiomatic expressions"
      pattern: "match_pattern"
    - from: "src/routing/router.py"
      to: "src/routing/scorer.py"
      via: "score_tool for ranking"
      pattern: "score_tool"
    - from: "src/routing/router.py"
      to: "llms.txt"
      via: "load tool metadata from Use for: hints"
      pattern: "llms\\.txt"
---

<objective>
Build the main routing logic that composes synonyms, patterns, date parsing, and scoring to resolve natural language queries to tool suggestions.

Purpose: Enable AI agents to discover the right tool from conversational business queries.
Output: Complete routing module with route_query() as the main entry point.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smart-routing/04-CONTEXT.md
@.planning/phases/04-smart-routing/04-RESEARCH.md
@.planning/phases/04-smart-routing/04-01-SUMMARY.md

Key decisions from CONTEXT.md:
- Return ALL matching tools, not just best guess
- Match detail: tool name + purpose + key params
- Vague queries: ask clarifying questions, don't guess
- Tie-breaking: alphabetical (A-Z)
- Action verbs (list/find/show) influence tool type ranking
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pattern library for idiomatic expressions</name>
  <files>src/routing/patterns.py</files>
  <action>
Create patterns.py with:

1. PATTERNS list of dicts, each with:
   - patterns: list of phrase variations (English + Indonesian)
   - tool: primary recommended tool
   - params: dict of suggested parameters (or "auto_date_*" for date hints)
   - alternative: optional secondary tool
   - confidence: "definitive" or "context-dependent"

Include these patterns from CONTEXT.md and disambiguation.md:
```python
PATTERNS = [
    {
        "patterns": ["outstanding invoices", "unpaid invoices", "faktur belum lunas", "faktur belum dibayar"],
        "tool": "invoice_list_sales",
        "params": {"status_id": 2},
        "confidence": "definitive"
    },
    {
        "patterns": ["who owes me money", "siapa yang hutang ke kita", "piutang belum dibayar", "accounts receivable"],
        "tool": "invoice_get_totals",
        "params": {},
        "alternative": "invoice_list_sales",
        "confidence": "context-dependent"
    },
    {
        "patterns": ["this month's revenue", "pendapatan bulan ini", "this month's sales", "penjualan bulan ini"],
        "tool": "financial_sales_summary",
        "params": "auto_date_this_month",
        "confidence": "definitive"
    },
    {
        "patterns": ["customers who haven't paid", "pelanggan yang belum bayar", "unpaid customers"],
        "tool": "invoice_list_sales",
        "params": {"status_id": 2},
        "confidence": "definitive"
    },
    {
        "patterns": ["top customers", "pelanggan terbesar", "best customers", "customer ranking"],
        "tool": "financial_sales_summary",
        "params": {},
        "confidence": "definitive"
    },
    {
        "patterns": ["pending deliveries", "pengiriman tertunda", "unshipped orders", "what needs to ship"],
        "tool": "delivery_get_pending",
        "params": {},
        "confidence": "definitive"
    },
    {
        "patterns": ["cash on hand", "saldo kas", "bank balances", "how much money do we have"],
        "tool": "financial_bank_balances",
        "params": {},
        "confidence": "definitive"
    },
    {
        "patterns": ["vendor spending", "pengeluaran ke vendor", "supplier costs", "what did we spend"],
        "tool": "financial_purchase_summary",
        "params": {},
        "confidence": "definitive"
    },
    {
        "patterns": ["customer history", "riwayat pelanggan", "transaction history", "what did customer buy"],
        "tool": "contact_get_transactions",
        "params": {},
        "confidence": "context-dependent"
    },
    {
        "patterns": ["overdue invoices", "faktur jatuh tempo", "late payments"],
        "tool": "invoice_get_totals",
        "params": {},
        "alternative": "invoice_list_sales",
        "confidence": "definitive"
    }
]
```

2. match_pattern(query: str) -> dict | None function:
   - Lowercase query
   - Check each pattern's phrases for substring match
   - Return first matching pattern dict, or None
  </action>
  <verify>
```python
from src.routing.patterns import match_pattern, PATTERNS
assert len(PATTERNS) >= 10
result = match_pattern("outstanding invoices")
assert result is not None
assert result["tool"] == "invoice_list_sales"
result = match_pattern("siapa yang hutang ke kita")
assert result is not None
assert result["tool"] == "invoice_get_totals"
```
  </verify>
  <done>Pattern library has 10+ idiomatic expressions with bilingual support</done>
</task>

<task type="auto">
  <name>Task 2: Create keyword extraction and relevance scoring</name>
  <files>src/routing/scorer.py</files>
  <action>
Create scorer.py with:

1. STOPWORDS set: Common words to ignore
   - English: show, me, the, my, a, an, get, find, what, is, are, can, you, i, want, to, see, all
   - Indonesian: tampilkan, saya, apa, berapa, ini, itu, yang, ke, dari, untuk, di

2. ACTION_VERBS dict: Maps action words to tool name suffixes
   - list/show/all -> "_list"
   - find/search/lookup -> "_search"
   - get/detail/info -> "_detail", "_get"
   - summary/report/total -> "_summary", "_totals"

3. extract_keywords(query: str) -> set[str]:
   - Tokenize with regex: \b\w+\b
   - Lowercase all tokens
   - Filter out stopwords and tokens < 2 chars
   - Return set of remaining keywords

4. score_tool(query_keywords: set[str], tool_name: str, tool_keywords: set[str]) -> float:
   - Base score: count of overlapping keywords between query and tool
   - Action verb boost (+0.5): If query has action verb and tool name has matching suffix
   - Return total score

5. load_tool_keywords() -> dict[str, set[str]]:
   - Parse llms.txt to extract "Use for:" hints per tool
   - Return dict mapping tool_name -> set of keywords from hints
   - Cache result (load once)
  </action>
  <verify>
```python
from src.routing.scorer import extract_keywords, score_tool, load_tool_keywords

kw = extract_keywords("show me outstanding invoices")
assert "outstanding" in kw
assert "invoices" in kw
assert "me" not in kw  # stopword

tool_kw = load_tool_keywords()
assert "invoice_list_sales" in tool_kw
assert len(tool_kw) >= 20  # Should have all tools

# Score with action verb match
score = score_tool({"list", "invoices"}, "invoice_list_sales", {"invoices", "billing"})
assert score > 1.0  # Base match + action boost
```
  </verify>
  <done>Keyword extraction removes stopwords, scoring includes action verb boost</done>
</task>

<task type="auto">
  <name>Task 3: Create main router with multi-tool suggestions</name>
  <files>src/routing/router.py, src/routing/__init__.py</files>
  <action>
Create router.py with:

1. Data classes:
```python
@dataclass
class ToolSuggestion:
    tool_name: str
    purpose: str
    key_params: list[str]
    suggested_params: dict
    score: float
    confidence: str  # "definitive" or "context-dependent"

@dataclass
class RoutingResult:
    query: str
    matched_tools: list[ToolSuggestion]
    clarification_needed: str | None
    date_range: tuple[str, str] | None
```

2. route_query(query: str) -> RoutingResult:
   Algorithm:
   a. Check for idiomatic pattern match first (match_pattern)
      - If matched, create ToolSuggestion from pattern with high score
      - Include alternative tool if exists
   b. Extract keywords from query (extract_keywords)
   c. Check for date expressions and parse (parse_natural_date)
   d. Normalize keywords via synonyms (normalize_term) and fuzzy (fuzzy_lookup)
   e. If < 2 meaningful keywords after processing, return clarification request:
      - clarification_needed = "What would you like to know? For example: invoices, customers, sales, products..."
   f. Score all tools against normalized keywords (score_tool)
   g. Filter tools with score > 0
   h. Sort by score descending, then alphabetically for ties
   i. Return top 5 suggestions with details

3. Get tool metadata (purpose, params) from llms.txt parsing or hardcoded mapping

Update src/routing/__init__.py:
```python
from .router import route_query, ToolSuggestion, RoutingResult
from .synonyms import normalize_term, SYNONYM_MAP, TERM_TO_TOOLS
from .date_parser import parse_natural_date
from .fuzzy import fuzzy_lookup
from .patterns import match_pattern, PATTERNS
from .scorer import extract_keywords, score_tool

__all__ = [
    "route_query", "ToolSuggestion", "RoutingResult",
    "normalize_term", "SYNONYM_MAP", "TERM_TO_TOOLS",
    "parse_natural_date", "fuzzy_lookup",
    "match_pattern", "PATTERNS",
    "extract_keywords", "score_tool",
]
```
  </action>
  <verify>
```python
from src.routing import route_query, RoutingResult

# Pattern match
result = route_query("outstanding invoices")
assert isinstance(result, RoutingResult)
assert len(result.matched_tools) >= 1
assert result.matched_tools[0].tool_name == "invoice_list_sales"

# Keyword match with multiple results
result = route_query("show invoices")
assert len(result.matched_tools) >= 2  # Multiple invoice tools

# Indonesian query
result = route_query("tampilkan faktur")
assert len(result.matched_tools) >= 1

# Vague query
result = route_query("show me data")
assert result.clarification_needed is not None

# Date extraction
result = route_query("invoices from last week")
assert result.date_range is not None
```
  </verify>
  <done>Router returns multiple ranked suggestions, handles patterns, supports bilingual queries</done>
</task>

</tasks>

<verification>
Complete routing module working:
```bash
python -c "
from src.routing import route_query

# Test cases
queries = [
    'outstanding invoices',
    'siapa yang hutang ke kita',
    'show customers',
    'tampilkan pelanggan',
    'revenue this month',
    'pendapatan bulan ini',
]

for q in queries:
    result = route_query(q)
    print(f'{q}: {[t.tool_name for t in result.matched_tools[:3]]}')
"
```
</verification>

<success_criteria>
- Pattern library has 10+ idiomatic expressions
- Keyword extraction filters stopwords correctly
- Scoring includes action verb boost
- route_query returns RoutingResult with multiple suggestions
- Bilingual queries (EN + ID) produce relevant results
- Vague queries return clarification prompt
- Date expressions extracted and included in result
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-routing/04-02-SUMMARY.md`
</output>
